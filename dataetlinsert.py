import json
import re
import requests
import mysql.connector
from mysql.connector import Error
from typing import List, Dict, Any

# ============================= 1. 用户配置区 =============================

# 请在此处配置您的数据库连接信息
DB_CONFIG = {
    'host': 'localhost',  # 数据库主机地址
    'user': 'root',  # 数据库用户名
    'password': 'Ec2024_12',  # 数据库密码
    'database': 'rsk_mail'  # 您创建的数据库名, e.g., 'rsk_data_v4'
}


# 您想要查询的公司列表
COMPANIES_TO_PROCESS = [
    "上海建工集团股份有限公司"
]

# 接口字典，用于构建请求和确定详情表名
# (table_prefix, chinese_name, detail_table_main_suffix)
# detail_table_main_suffix is typically 'detail' as generated by apijsontosql4.py for the main content of row_content
INTERFACE_DICT = {
    "1049": ("credit_ratings", "企业信用评级", "credit_ratings_detail"),
    "884": ("tax_ratings", "税务评级", "tax_ratings_detail"),
    "1163": ("person_legal_proceedings", "法律诉讼(人员)", "person_legal_proceedings_detail"), # Adjust suffix if apijsontosql4 generates different
    # "1036": ("bankruptcy_cases", "破产重整", "bankruptcy_cases_detail"),
    # "843": ("dishonest_persons", "失信人", "dishonest_persons_detail"),
}
# 注意: 上述 detail_table_main_suffix 需要与 apijsontosql4.py 生成的表名对应。
# 例如，如果 API 1049 的 row_content 直接字段生成在 credit_ratings_detail 表，则此处正确。
# 如果 apijsontosql4.py 为 API 1049 的 row_content 生成了 credit_ratings_items_detail，则需要修改。
# 通常，对于 row_content 的直接子字段，apijsontosql4.py 会生成 `interface_table_prefix_detail`。


# ============================= 2. 辅助函数和数据库操作 =============================

def to_snake_case(name: str) -> str:
    """驼峰命名转蛇形命名 (e.g., regStatus -> reg_status)"""
    name = re.sub(r'([a-z\d])([A-Z])', r'\1_\2', name)
    return name.replace("__", "_").lower()


def create_db_connection():
    """创建并返回一个数据库连接"""
    try:
        connection = mysql.connector.connect(**DB_CONFIG)
        if connection.is_connected():
            print("数据库连接成功。")
            return connection
    except Error as e:
        print(f"数据库连接失败: {e}")
        return None


def fetch_api_data(company_name: str, api_id: str) -> List[Dict[str, Any]] | None:
    """
    从业务接口获取指定公司的数据。
    """
    # api_path (table_prefix) is implicitly known via api_id in INTERFACE_DICT
    url = f"http://10.50.74.8:38081/fireeyes/interface" # 您的API URL
    headers = {
        'Content-Type': 'application/json',
        'x-scg-requestid': '', # 根据需要填写
        'x-scg-servicename': 'S_XXX_XXX_XXXX', # 根据需要填写
        'x-scg-caller': 'DMS' # 根据需要填写
    }
    params = {
        "name": company_name,
        "user_code": "DMS", # 根据需要填写
        "interface_id": str(api_id), #确保是字符串
        "is_need_update_period": False
    }

    print(f"  正在从接口 ID '{api_id}' 获取 '{company_name}' 的数据...")
    try:
        response = requests.post(url, data=json.dumps(params), headers=headers, timeout=20)
        response.raise_for_status()  # 如果请求失败 (4xx, 5xx) 则抛出异常

        result = response.json()
        # print(f"Raw API response for {api_id}: {json.dumps(result, ensure_ascii=False, indent=2)}") # 调试时取消注释

        if result.get('err_code') == 0:
            items = result.get('items')
            if items is not None: # API 可能成功但items为null或空列表
                 print(f"  成功获取 {len(items)} 条数据。")
                 return items
            else:
                print(f"  成功获取数据，但 'items' 字段为空或不存在。")
                return [] # 返回空列表表示无数据条目
        else:
            print(f"  API 返回错误 (err_code: {result.get('err_code')}): {result.get('reason', '无具体错误信息')}")
            return None

    except requests.exceptions.Timeout:
        print(f"  请求 API ID '{api_id}' 超时。")
        return None
    except requests.exceptions.RequestException as e:
        print(f"  请求 API ID '{api_id}' 时发生网络错误: {e}")
        return None
    except json.JSONDecodeError:
        print(f"  无法解析 API ID '{api_id}' 返回的 JSON 数据。原始响应: {response.text[:500]}...") #打印部分原始响应
        return None


def insert_master_data(cursor, item_data: Dict[str, Any]) -> int | None:
    """
    将主数据插入到 `api_response_items` 表。
    返回新插入行的 ID。
    """
    master_data = {
        'company_name': item_data.get('name'),
        'disabled': item_data.get('disabled'),
        'last_update_time': item_data.get('last_update_time'),
        'interface_id': item_data.get('interface_id'),
        'interface_name': item_data.get('interface_name')
    }
    # 过滤掉值为 None 的字段，避免数据库错误 (如果列不允许NULL且无默认值)
    master_data_cleaned = {k: v for k, v in master_data.items() if v is not None}

    columns = list(master_data_cleaned.keys())
    placeholders = ['%s'] * len(columns)

    sql = f"INSERT INTO `api_response_items` ({', '.join(columns)}) VALUES ({', '.join(placeholders)})"

    try:
        values = list(master_data_cleaned.values())
        cursor.execute(sql, values)
        return cursor.lastrowid
    except Error as e:
        print(f"\n[数据库错误] 插入到主表 `api_response_items` 失败: {e}")
        print(f"  - SQL: {sql}")
        print(f"  - Data: {master_data_cleaned}")
        raise # 回滚事务


def insert_detail_data(cursor, detail_table_name: str, detail_data: Dict[str, Any], master_item_id: int):
    """
    将行项目内容 (row_content) 插入到对应的详情表。
    """
    if not isinstance(detail_data, dict):
        print(f"  [警告] 详情数据不是字典格式，无法插入到 {detail_table_name}。数据: {detail_data}")
        return

    # 为详情数据添加外键
    data_to_insert = {to_snake_case(key): value for key, value in detail_data.items()}
    data_to_insert['master_item_id'] = master_item_id

    # 过滤掉值为 None 的字段
    data_to_insert_cleaned = {k: v for k, v in data_to_insert.items() if v is not None}
    if not data_to_insert_cleaned or 'master_item_id' not in data_to_insert_cleaned: # Ensure master_item_id is there
        if not any(k for k in detail_data.keys()): # if original detail_data was empty
            print(f"  [信息] row_content 为空，不向详情表 `{detail_table_name}` 插入数据。")
            return
        else: # Should not happen if master_item_id is always added
            print(f"  [警告] 清理后详情数据为空，无法插入到 {detail_table_name}。原始数据: {detail_data}")
            return


    columns = list(data_to_insert_cleaned.keys())
    placeholders = ['%s'] * len(columns)
    sql = f"INSERT INTO `{detail_table_name}` ({', '.join(columns)}) VALUES ({', '.join(placeholders)})"

    try:
        values = list(data_to_insert_cleaned.values())
        cursor.execute(sql, values)
    except Error as e:
        print(f"\n[数据库错误] 插入到详情表 `{detail_table_name}` 失败: {e}")
        print(f"  - SQL: {sql}")
        print(f"  - Data: {data_to_insert_cleaned}")
        # 检查是否因为列不存在导致错误
        if e.errno == 1054: # ER_BAD_FIELD_ERROR
            print(f"  [提示] 请检查表 `{detail_table_name}` 是否包含以下所有列 (蛇形命名): {list(data_to_insert_cleaned.keys())}")
            print(f"          或者 `apijsontosql4.py` 生成的表结构是否与实际数据字段匹配。")
        raise # 回滚事务

# ============================= 3. 核心处理逻辑 (已修改) =============================

def process_and_insert_api_items(
    cursor,
    api_items: List[Dict[str, Any]],
    interface_id_str: str # API ID as string
):
    """
    处理从API获取的items列表，将其插入到主表和相应的详情表。
    """
    if interface_id_str not in INTERFACE_DICT:
        print(f"  [警告] 接口ID '{interface_id_str}' 未在 INTERFACE_DICT中配置，跳过处理。")
        return

    _, _, detail_table_name_suffix = INTERFACE_DICT[interface_id_str]
    # The actual detail_table_name is derived from apijsontosql4.py logic,
    # which is typically interface_table_prefix + "_detail".
    # Example: if INTERFACE_DICT["1049"] = ("credit_ratings", ..., ...)
    # then detail_table_name = "credit_ratings_detail"
    detail_table_name = detail_table_name_suffix # Assuming suffix is full name for now.
                                                # Or construct it: `f"{INTERFACE_DICT[interface_id_str][0]}_detail"`

    for item in api_items:
        # 1. 插入主数据到 api_response_items
        master_id = insert_master_data(cursor, item)
        if master_id is None:
            print(f"  [错误] 插入主数据失败，跳过此条目: {item.get('name')}")
            continue # or raise error to stop all if critical

        print(f"    - 主数据插入到 `api_response_items` (ID: {master_id}) for company '{item.get('name')}'")

        # 2. 获取 row_content 并插入到对应的详情表
        row_content = item.get('row_content')
        if row_content and isinstance(row_content, dict):
            # Special handling for known nested structures might be needed here if apijsontosql4 creates multiple detail tables
            # For now, assumes row_content fields go into one primary detail table.
            insert_detail_data(cursor, detail_table_name, row_content, master_id)
            print(f"      - 详情数据插入到 `{detail_table_name}` (master_item_id: {master_id})")
        elif row_content:
            print(f"      - [警告] `row_content` 不是预期的字典格式，无法处理。内容: {type(row_content)}")
        else:
            print(f"      - [信息] 此条目无 `row_content` 数据。")


# ============================= 4. 主执行函数 (已修改) =============================

def main():
    """主执行函数"""
    connection = create_db_connection()
    if not connection:
        print("无法连接到数据库，程序退出。")
        return

    cursor = connection.cursor()

    try:
        for company_name in COMPANIES_TO_PROCESS:
            print(f"\n{'=' * 20} 开始处理公司: {company_name} {'=' * 20}")

            for api_id_str, config_tuple in INTERFACE_DICT.items():
                # table_prefix = config_tuple[0] # Not directly used for table name here, but good for context
                chinese_name = config_tuple[1]
                print(f"\n  处理接口: {chinese_name} (ID: {api_id_str})")

                # 从API获取数据
                # fetch_api_data now takes api_id_str instead of table_prefix
                api_items_data = fetch_api_data(company_name, api_id_str)

                if api_items_data is not None: # Check for None explicitly, empty list is valid
                    if api_items_data: # If list is not empty
                        process_and_insert_api_items(cursor, api_items_data, api_id_str)
                    else:
                        print(f"    接口 {chinese_name} (ID: {api_id_str}) 对公司 '{company_name}' 返回了空列表，无需插入数据。")
                else:
                    # Error occurred in fetch_api_data, message already printed
                    print(f"    未能获取接口 {chinese_name} (ID: {api_id_str}) 的数据，跳过。")

            # 处理完一个公司的所有接口后，提交事务
            print(f"\n完成公司 '{company_name}' 的所有数据处理，准备提交事务。")
            connection.commit()
            print(f"事务已提交。")

    except Exception as e:
        print(f"\n处理过程中发生未捕获的严重错误: {e}。事务将被回滚。")
        if connection.is_connected(): # Ensure connection exists before rollback
            connection.rollback()
            print("事务已回滚。")
    finally:
        if connection and connection.is_connected(): # Check connection and cursor objects exist
            if cursor:
                cursor.close()
            connection.close()
            print("\n数据库连接已关闭。")


if __name__ == '__main__':
    if DB_CONFIG.get('user') == 'your_username' or DB_CONFIG.get('database') == 'rsk_mail_v3_example':
        print("-" * 60)
        print("[警告] 请务必在脚本顶部更新您的 `DB_CONFIG` 数据库连接信息！")
        print(f"        当前用户: {DB_CONFIG.get('user')}, 数据库: {DB_CONFIG.get('database')}")
        print("-" * 60)
    else:
        main()
        print("\n--- 数据ETL过程执行完毕 ---")
        print("请检查数据库中的 `api_response_items` 表以及相关的详情表 (例如 `credit_ratings_detail`)。")
        print("同时留意控制台输出中是否有错误或警告信息。")
